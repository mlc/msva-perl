#!/usr/bin/perl -wT

# Monkeysphere Validation Agent, Perl version
# Copyright Â© 2010 Daniel Kahn Gillmor <dkg@fifthhorseman.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use warnings;
use strict;

{
  package MSVA;

  use parent qw(HTTP::Server::Simple::CGI);
  require Crypt::GPG;
  require Crypt::X509;
  use Convert::ASN1;
  use MIME::Base64;

  use JSON;
  use POSIX qw(strftime);

  my %dispatch = (
                  '/' => { handler => \&noop,
                           methods => { 'GET' => 1 },
                         },
                  '/reviewcert' => { handler => \&reviewcert,
                                     methods => { 'POST' => 1 },
                                   },
                  '/extracerts' => { handler => \&extracerts,
                                     methods => { 'POST' => 1 },
                                   },
                 );

  my %loglevels = (
                   'silent' => 1,
                   'quiet' => 2,
                   'fatal' => 3,
                   'error' => 4,
                   'info' => 5,
                   'verbose' => 6,
                   'debug' => 7,
                   'debug1' => 7,
                   'debug2' => 8,
                   'debug3' => 9,
                  );

my $rsa_decoder = Convert::ASN1->new;
$rsa_decoder->prepare(q<

   SEQUENCE {
        modulus INTEGER,
        exponent INTEGER
   }
          >);

#   $rsa_decoder->configure(-options => 'DER');

  sub msvalog {
#    my $self = shift;
    my $msglevel = shift;

    my $level = $loglevels{lc($ENV{MSVA_LOG_LEVEL})};
    $level = $loglevels{info} if (! defined $level);

    if ($loglevels{lc($msglevel)} <= $level) {
      printf STDERR @_;
    }
  };

  sub new {
    my $class = shift;
    # start the server on port 8901
    my $self = $class->SUPER::new(8901);

    $self->{_gpg} = new Crypt::GPG;


    bless ($self, $class);
    return $self;
  }

  sub noop {
    my $self = shift;
    my $cgi = shift;
    return '200 OK', { available => JSON::true,
                       protoversion => 1,
                       server => "MSVA-Perl 0.1" };
  }

  # returns an empty list if bad key found.
  sub parse_openssh_pubkey {
    my $data = shift;
    my ($label, $prop) = split(/ +/, $data);
    $prop = decode_base64($prop) or return ();

    msvalog('debug', "key properties: %s\n", unpack('H*', $prop));
    my @out;
    while (length($prop) > 4) {
      my $size = unpack('N', substr($prop, 0, 4));
      msvalog('debug', "size: 0x%08x\n", $size);
      return () if (length($prop) < $size + 4);
      push(@out, substr($prop, 4, $size));
      $prop = substr($prop, 4 + $size);
    }
    return () if ($label ne $out[0]);
    return @out;
  }

  sub handle_request {
    my $self = shift;
    my $cgi  = shift;

    # FIXME: check SO_PEERCRED -- if this was a TCP socket, Linux
    # might not be able to support SO_PEERCRED (even on the loopback),
    # though apparently some kernels (Solaris?) are able to.

    # another option in Linux would be to parse the contents of
    # /proc/net/tcp to find the uid of the peer process based on that
    # information.

    my $path = $cgi->path_info();
    my $handler = $dispatch{$path};

    if (ref($handler) eq "HASH") {
      if (! exists $handler->{methods}->{$cgi->request_method()}) {
        printf("HTTP/1.0 405 Method not allowed\r\nAllow: %s\r\nDate: %s\r\n",
               join(', ', keys(%{$handler->{methods}})),
               strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())));
      } elsif (ref($handler->{handler}) ne "CODE") {
        printf("HTTP/1.0 500 Server Error\r\nDate: %s\r\n",
               strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())));
      } else {
        my $data = {};
        my $ctype = $cgi->content_type();
        msvalog('verbose', "Got %s %s (Content-Type: %s)\n", $cgi->request_method(), $path, defined $ctype ? $ctype : '**none supplied**');
        if (defined $ctype) {
          my @ctypes = split(/; */, $ctype);
          $ctype = shift @ctypes;
          if ($ctype eq 'application/json') {
            $data = from_json($cgi->param('POSTDATA'));
          }
        };

        my ($status, $object) = $handler->{handler}($data);
        my $ret = to_json($object);
        msvalog('info', "returning: %s\n", $ret);
        printf("HTTP/1.0 %s\r\nDate: %s\r\nContent-Type: application/json\r\n\r\n%s",
               $status,
               strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())),
               $ret);
      }
    } else {
      printf("HTTP/1.0 404 Not Found -- not handled by Monkeysphere validation agent\r\nContent-Type: text/plain\r\nDate: %s\r\n\r\nHTTP/1.0 404 Not Found -- the path:\r\n   %s\r\nis not handled by the MonkeySphere validation agent.\r\nPlease try one of the following paths instead:\r\n\r\n%s\r\n",
             strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())),
             $path, ' * '.join("\r\n * ", keys %dispatch) );
    }
  }



  sub reviewcert {
    my $data  = shift;
    return if !ref $data;

    my $uid = $data->{context}.'://'.$data->{peer};

    my $rawdata = join('', map(chr, @{$data->{pkc}->{data}}));
    my $cert = Crypt::X509->new(cert => $rawdata);
    msvalog('verbose', "cert subject: %s\n", $cert->subject_cn());
    msvalog('verbose', "cert issuer: %s\n", $cert->issuer_cn());
    msvalog('verbose', "cert pubkey algo: %s\n", $cert->PubKeyAlg());
    msvalog('verbose', "cert pubkey: %s\n", unpack('H*', $cert->pubkey()));

    my $status = '200 OK';
    my $ret =  { valid => JSON::false,
                 message => 'Unknown failure',
               };
    if ($cert->PubKeyAlg() ne 'RSA') {
      $ret->{message} = sprintf('public key was algo "%s" (OID %s).  MSVA.pl only supports RSA',
                                $cert->PubKeyAlg(), $cert->pubkey_algorithm);
    } else {
      my $key = $rsa_decoder->decode($cert->pubkey());
      if ($key) {
        # make sure that the returned integers are Math::BigInts:
        $key->{exponent} = Math::BigInt->new($key->{exponent}) unless (ref($key->{exponent}));
        $key->{modulus} = Math::BigInt->new($key->{modulus}) unless (ref($key->{modulus}));
        msvalog('debug', "cert info:\nmodulus: %s\nexponent: %s\n",
                $key->{modulus}->as_hex(),
                $key->{exponent}->as_hex(),
               );

        if ($key->{modulus}->copy()->blog(2) < 1000) { # FIXME: this appears to be the full pubkey, including DER overhead
          $ret->{message} = sprintf('public key size is less than 1000 bits (was: %d bits)', $cert->pubkey_size());
        } else {
          $ret->{message} = sprintf('tried to validate "%s" through the OpenPGP Web of Trust, failed.', $uid);

          my $fh;
          # clean up the path for taint-check mode:
          $ENV{PATH} = '/usr/local/bin:/usr/bin:/bin';

          open($fh, '-|', 'monkeysphere', 'keys-for-userid', $uid);
          while(<$fh>) {
            my @keyinfo = parse_openssh_pubkey($_);
            if (scalar(@keyinfo) != 3 || $keyinfo[0] ne "ssh-rsa") {
              msvalog('info', "got unknown or non-RSA key from monkeysphere\n");
              next;
            }
            msvalog('verbose', "got good RSA key from monkeysphere: \nExponent: 0x%s\nModulus: 0x%s\n", unpack('H*', $keyinfo[1]), unpack('H*', $keyinfo[2]));
            if ($key->{exponent}->bcmp(Math::BigInt->new('0x'.unpack('H*', $keyinfo[1]))) == 0 &&
                $key->{modulus}->bcmp(Math::BigInt->new('0x'.unpack('H*', $keyinfo[2]))) == 0) {
              msvalog('verbose', "...and it matches!\n");
              $ret->{valid} = JSON::true;
              $ret->{message} = sprintf('Successfully validated "%s" through the OpenPGP Web of Trust.', $uid);
            }
          }
        }
      } else {
        msvalog('error', "failed to decode %s\n", unpack('H*', $cert->pubkey()));
        $ret->{message} = sprintf('failed to decode the public key', $uid);
      }
    }

    return $status, $ret;
  }

  sub extracerts {
    my $data = shift;

    return '500 not yet implemented', { };
  }

  1;
}

my $server = MSVA->new();
$server->run();
